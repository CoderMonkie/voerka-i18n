# 文本映射<!-- {docsify-ignore-all} -->

虽然`VoerkaI18n`推荐采用`t("中华人民共和国万岁")`形式的符合直觉的翻译形式，而不是采用`t("xxxx.xxx")`这样不符合直觉的形式，但是为什么大部份的国际化方案均采用`t("xxxx.xxx")`形式？

在我们的方案中，`t("中华人民共和国万岁"`)`形式相当于采用原始文本进行查表，语言名形式如下：

```javascript
// en.js
{
    "中华人民共和国":"the people's Republic of China"
}
// jp.js
{
    "中华人民共和国":"中華人民共和国"
}
```

很显然，直接使用文本内容作为`key`，虽然符合直觉，但是会造成大量的冗余信息。因此，`voerkai18n compile`会将之编译成如下：

```javascript
//idMap.js
{
    "中华人民共和国万岁":"1"
}
// en.js
{
    "1":"Long live the people's Republic of China"
}
// jp.js
{
    "2":"中華人民共和国"
}
```

如此，就消除了在`en.js`、`jp.js`文件中的冗余。但是在源代码文件中还存在`t("中华人民共和国万岁")`，整个运行环境中存在两份副本，一份在`源代码`文件中，一份在`idMap.js`中。

为了进一步减少冗余内容，因此，我们需要将源代码文件中的`t("中华人民共和国万岁")`更改为`t("1")`，这样就能确保无重复冗余。但是，很显然，我们不可能手动来更改源代码文件，这就需要由`voerkai18n`提供的一个编译期插件来做这一件事了。

以`babel-plugin-voerkai18n`插件为例，该插件同时还完成一项任务，就是自动读取`voerkai18n compile`生成的`idMap.js`文件，然后将`t("中华人民共和国万岁")`自动更改为`t("1")`，这样就完全消除了重复冗余信息。

所以，在最终形成编译后的代码中，实际上每一个t函数均是`t("1")`、`t("2")`、`t("3")`、`...`、`t("n")`的形式，最终代码还是采用了用`key`来进行转换，只不过这个过程是自动完成的而已。

**注意：**

- 如果没有启用`babel-plugin-voerkai18n`或`vite`等编译期插件，还是可以正常工作，但是会有一份默认语言的冗余信息存在。