# 文本映射

虽然`VoerkaI18n`推荐采用`t("VoerkaI18n是一个非常不错的国际化方案")`形式的符合直觉的翻译形式，而不是采用`t("xxxx.xxx")`这样不符合直觉的形式，但是为什么大部份的国际化方案均采用`t("xxxx.xxx")`形式？

在我们的方案中，`t("VoerkaI18n是一个非常不错的国际化方案"`)`形式相当于采用原始文本进行查表，语言名形式如下：

```javascript
// en.js
{
    "中华人民共和国":"the people's Republic of China"
}
// jp.js
{
    "中华人民共和国":"中華人民共和国"
}
```

很显然，直接使用文本内容作为`key`，虽然符合直觉，但是会造成大量的冗余信息。因此，`voerkai18n compile`会将之编译成如下：

```javascript
//idMap.js
{
    "VoerkaI18n是一个非常不错的国际化方案":"1"
}
// en.js
{
    "1":"Long live the people's Republic of China"
}
// jp.js
{
    "2":"中華人民共和国"
}
```

如此，就消除了在`en.js`、`jp.js`文件中的冗余。但是在源代码文件中还存在`t("VoerkaI18n是一个非常不错的国际化方案")`，整个运行环境中存在两份副本，一份在`源代码`文件中，一份在`idMap.js`中。

为了进一步减少冗余内容，因此，我们需要将源代码文件中的`t("VoerkaI18n是一个非常不错的国际化方案")`更改为`t("1")`，这样就能确保无重复冗余。但是，很显然，我们不可能手动来更改源代码文件，这就需要由`voerkai18n`提供的一个编译期插件来做这一件事了。

`@voerkai18n/plugins`是一个通过`vite/webpack/rollup`等构建工具来实现的编译期插件，它会在编译期将根据`IdMap.json`信誓旦文件将`t("VoerkaI18n是一个非常不错的国际化方案")`转换为`t("1")`。

所以，在最终形成编译后的代码中，实际上每一个t函数均是`t("1")`、`t("2")`、`t("3")`、`...`、`t("n")`的形式，最终代码还是采用了用`key`来进行转换，只不过这个过程是自动完成的而已。

**注意：**

- 如果没有启用`@voerkai18n/plugins`或`vite`等编译期插件，还是可以正常工作，但是会有一份默认语言的冗余信息存在。