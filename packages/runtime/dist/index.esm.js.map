{"version":3,"file":"index.esm.js","sources":["../utils.js","../eventemitter.js","../scope.js","../index.js","../formatters.js"],"sourcesContent":["\r\n/**\r\n * 判断是否是JSON对象\r\n * @param {*} obj \r\n * @returns \r\n */\r\n function isPlainObject(obj){\r\n    if (typeof obj !== 'object' || obj === null) return false;\r\n    var proto = Object.getPrototypeOf(obj);\r\n    if (proto === null) return true;\r\n    var baseProto = proto;\r\n\r\n    while (Object.getPrototypeOf(baseProto) !== null) {\r\n        baseProto = Object.getPrototypeOf(baseProto);\r\n    }\r\n    return proto === baseProto; \r\n}\r\n\r\nfunction isNumber(value){\r\n    return !isNaN(parseInt(value))\r\n}\r\n \r\n/**\r\n * 简单进行对象合并\r\n * \r\n * options={\r\n *    array:0 ,        // 数组合并策略，0-替换，1-合并，2-去重合并\r\n * }\r\n * \r\n * @param {*} toObj \r\n * @param {*} formObj \r\n * @returns 合并后的对象\r\n */\r\nfunction deepMerge(toObj,formObj,options={}){\r\n    let results = Object.assign({},toObj)\r\n    Object.entries(formObj).forEach(([key,value])=>{\r\n        if(key in results){\r\n            if(typeof value === \"object\" && value !== null){\r\n                if(Array.isArray(value)){\r\n                    if(options.array === 0){\r\n                        results[key] = value\r\n                    }else if(options.array === 1){\r\n                        results[key] = [...results[key],...value]\r\n                    }else if(options.array === 2){\r\n                        results[key] = [...new Set([...results[key],...value])]\r\n                    }\r\n                }else{\r\n                    results[key] = deepMerge(results[key],value,options)\r\n                }\r\n            }else{\r\n                results[key] = value\r\n            }\r\n        }else{\r\n            results[key] = value\r\n        }\r\n    })\r\n    return results\r\n}\r\n\r\n\r\n/**\r\n * 获取指定变量类型名称\r\n * getDataTypeName(1) == Number\r\n * getDataTypeName(\"\") == String\r\n * getDataTypeName(null) == Null\r\n * getDataTypeName(undefined) == Undefined\r\n * getDataTypeName(new Date()) == Date\r\n * getDataTypeName(new Error()) == Error\r\n * \r\n * @param {*} v \r\n * @returns \r\n */\r\n function getDataTypeName(v){\r\n\tif (v === null)  return 'Null' \r\n\tif (v === undefined) return 'Undefined'   \r\n    if(typeof(v)===\"function\")  return \"Function\"\r\n\treturn v.constructor && v.constructor.name;\r\n};\r\n\r\n\r\n\r\n\r\n\r\nmodule.exports ={\r\n    isPlainObject,\r\n    isNumber,\r\n    deepMerge,\r\n    getDataTypeName\r\n}","/**\r\n* \r\n* 简单的事件触发器\r\n* \r\n*/\r\nmodule.exports = class EventEmitter{\r\n    constructor(){\r\n        this._callbacks = []\r\n    }\r\n    on(callback){\r\n        if(this._callbacks.includes(callback)) return\r\n        this._callbacks.push(callback)\r\n    }\r\n    off(callback){\r\n        for(let i=0;i<this._callbacks.length;i++){\r\n            if(this._callbacks[i]===callback ){\r\n                this._callbacks.splice(i,1)\r\n            }\r\n        }\r\n    }\r\n    offAll(){\r\n        this._callbacks = []\r\n    }\r\n    async emit(...args){\r\n        if(Promise.allSettled){\r\n            await Promise.allSettled(this._callbacks.map(cb=>cb(...args)))\r\n        }else{\r\n            await Promise.all(this._callbacks.map(cb=>cb(...args)))\r\n        }\r\n    }    \r\n}","\r\n\r\nconst DataTypes = [\"String\",\"Number\",\"Boolean\",\"Object\",\"Array\",\"Function\",\"Null\",\"Undefined\",\"Symbol\",\"Date\",\"RegExp\",\"Error\"];\r\n\r\nmodule.exports = class i18nScope {\r\n    constructor(options={},callback){\r\n        // 每个作用域都有一个唯一的id\r\n        this._id              = options.id || (new Date().getTime().toString()+parseInt(Math.random()*1000))\r\n        this._languages       = options.languages                               // 当前作用域的语言列表\r\n        this._defaultLanguage = options.defaultLanguage || \"zh\"                 // 默认语言名称\r\n        this._activeLanguage  = options.activeLanguage                        // 当前语言名称\r\n        this._default         = options.default                                 // 默认语言包\r\n        this._messages        = options.messages                                // 当前语言包\r\n        this._idMap           = options.idMap                                   // 消息id映射列表\r\n        this._formatters      = options.formatters                              // 当前作用域的格式化函数列表\r\n        this._loaders         = options.loaders                                 // 异步加载语言文件的函数列表\r\n        this._global          = null                                            // 引用全局VoerkaI18n配置，注册后自动引用     \r\n        // 主要用来缓存格式化器的引用，当使用格式化器时可以直接引用，避免检索\r\n        this.$cache={\r\n            activeLanguage : null,\r\n            typedFormatters: {},\r\n            formatters     : {},\r\n        }\r\n        // 如果不存在全局VoerkaI18n实例，说明当前Scope是唯一或第一个加载的作用域，\r\n        // 则使用当前作用域来初始化全局VoerkaI18n实例\r\n        if(!globalThis.VoerkaI18n){\r\n            const { I18nManager } = require(\"./\")\r\n            globalThis.VoerkaI18n = new I18nManager({\r\n                defaultLanguage: this.defaultLanguage,\r\n                activeLanguage : this.activeLanguage,\r\n                languages: options.languages,\r\n            })\r\n        }\r\n        this.global = globalThis.VoerkaI18n \r\n        // 正在加载语言包标识\r\n        this._loading=false\r\n        // 在全局注册作用域\r\n        this.register(callback)\r\n    }\r\n    // 作用域\r\n    get id(){return this._id}\r\n    // 默认语言名称\r\n    get defaultLanguage(){return this._defaultLanguage}\r\n    // 默认语言名称\r\n    get activeLanguage(){return this._activeLanguage}\r\n    // 默认语言包\r\n    get default(){return this._default}\r\n    // 当前语言包\r\n    get messages(){return this._messages}\r\n    // 消息id映射列表\r\n    get idMap(){return this._idMap}\r\n    // 当前作用域的格式化函数列表\r\n    get formatters(){return this._formatters}\r\n    // 异步加载语言文件的函数列表\r\n    get loaders(){return this._loaders}\r\n    // 引用全局VoerkaI18n配置，注册后自动引用\r\n    get global(){return this._global}\r\n    set global(value){this._global = value}\r\n    /**\r\n     * 在全局注册作用域\r\n     * @param {*} callback   当注册\r\n     */\r\n    register(callback){\r\n        if(!typeof(callback)===\"function\") callback = ()=>{} \r\n        this.global.register(this).then(callback).catch(callback)    \r\n    }\r\n    registerFormatter(name,formatter,{language=\"*\"}={}){\r\n        if(!typeof(formatter)===\"function\" || typeof(name)!==\"string\"){\r\n            throw new TypeError(\"Formatter must be a function\")\r\n        }        \r\n        if(DataTypes.includes(name)){\r\n            this.formatters[language].$types[name] = formatter\r\n        }else{\r\n            this.formatters[language][name] = formatter\r\n        }\r\n    }\r\n    /**\r\n     * 回退到默认语言\r\n     */\r\n    _fallback(){\r\n        this._messages = this._default  \r\n        this._activeLanguage = this.defaultLanguage\r\n    }\r\n    /**\r\n     * 刷新当前语言包\r\n     * @param {*} newLanguage \r\n     */\r\n    async refresh(newLanguage){\r\n        this._loading = Promise.resolve()\r\n        if(!newLanguage) newLanguage = this.activeLanguage\r\n        // 默认语言，默认语言采用静态加载方式，只需要简单的替换即可\r\n        if(newLanguage === this.defaultLanguage){\r\n            this._messages = this._default\r\n            return \r\n        }\r\n        // 非默认语言需要异步加载语言包文件,加载器是一个异步函数\r\n        // 如果没有加载器，则无法加载语言包，因此回退到默认语言\r\n        const loader = this.loaders[newLanguage]\r\n        if(typeof(loader) === \"function\"){\r\n            try{\r\n                this._messages  = (await loader()).default\r\n                this._activeLanguage = newLanguage\r\n            }catch(e){\r\n                console.warn(`Error while loading language <${newLanguage}> on i18nScope(${this.id}): ${e.message}`)\r\n                this._fallback()\r\n            }       \r\n        }else{\r\n            this._fallback()\r\n        }   \r\n    }\r\n    // 以下方法引用全局VoerkaI18n实例的方法\r\n    get on(){return this.global.on.bind(this.global)}\r\n    get off(){return this.global.off.bind(this.global)}\r\n    get offAll(){return this.global.offAll.bind(this.global)}\r\n    get change(){\r\n        return this.global.change.bind(this.global)\r\n    }\r\n}","const { getDataTypeName,isNumber,isPlainObject,deepMerge } = require(\"./utils\")\r\nconst EventEmitter = require(\"./eventemitter\")\r\nconst i18nScope = require(\"./scope.js\")\r\nlet  inlineFormatters = require(\"./formatters\")         // 内置格式化器\r\n\r\n\r\n\r\n// 用来提取字符里面的插值变量参数 , 支持管道符 { var | formatter | formatter }\r\n// 不支持参数： let varWithPipeRegexp = /\\{\\s*(?<varname>\\w+)?(?<formatters>(\\s*\\|\\s*\\w*\\s*)*)\\s*\\}/g\r\n\r\n// 支持参数： { var | formatter(x,x,..) | formatter }\r\nlet varWithPipeRegexp = /\\{\\s*(?<varname>\\w+)?(?<formatters>(\\s*\\|\\s*\\w*(\\(.*\\)){0,1}\\s*)*)\\s*\\}/g\r\n\r\n// 插值变量字符串替换正则\r\n\r\n//let varReplaceRegexp =String.raw`\\{\\s*(?<var>{name}\\.?\\w*)\\s*\\}`\r\n\r\n\r\nlet varReplaceRegexp =String.raw`\\{\\s*{varname}\\s*\\}`\r\n\r\n/**\r\n * 考虑到通过正则表达式进行插件的替换可能较慢，因此提供一个简单方法来过滤掉那些\r\n * 不需要进行插值处理的字符串\r\n * 原理很简单，就是判断一下是否同时具有{和}字符，如果有则认为可能有插值变量，如果没有则一定没有插件变量，则就不需要进行正则匹配\r\n * 从而可以减少不要的正则匹配\r\n * 注意：该方法只能快速判断一个字符串不包括插值变量\r\n * @param {*} str \r\n * @returns {boolean}  true=可能包含插值变量,\r\n */\r\nfunction hasInterpolation(str){\r\n    return str.includes(\"{\") && str.includes(\"}\")\r\n} \r\nconst DataTypes =  [\"String\",\"Number\",\"Boolean\",\"Object\",\"Array\",\"Function\",\"Error\",\"Symbol\",\"RegExp\",\"Date\",\"Null\",\"Undefined\",\"Set\",\"Map\",\"WeakSet\",\"WeakMap\"]\r\n \r\n\r\n/**\r\n   通过正则表达式对原始文本内容进行解析匹配后得到的\r\n   formatters=\"| aaa(1,1) | bbb \"\r\n\r\n   需要统一解析为\r\n\r\n   [\r\n       [aaa,[1,1]],         // [formatter'name,[args,...]]\r\n       [bbb,[]],\r\n   ]\r\n\r\n   formatters=\"| aaa(1,1,\"dddd\") | bbb \"\r\n\r\n   目前对参数采用简单的split(\",\")来解析，因为无法正确解析aaa(1,1,\"dd,,dd\")形式的参数\r\n   在此场景下基本够用了，如果需要支持更复杂的参数解析，可以后续考虑使用正则表达式来解析\r\n   \r\n   @returns  [[<formatterName>,[<arg>,<arg>,...]]]\r\n */\r\nfunction parseFormatters(formatters){\r\n    if(!formatters) return []\r\n    // 1. 先解析为 [\"aaa()\",\"bbb\"]形式\r\n    let result = formatters.trim().substr(1).trim().split(\"|\").map(r=>r.trim())  \r\n\r\n    // 2. 解析格式化器参数\r\n    return result.map(formatter=>{\r\n        let firstIndex = formatter.indexOf(\"(\")\r\n        let lastIndex = formatter.lastIndexOf(\")\")\r\n        if(firstIndex!==-1 && lastIndex!==-1){ // 带参数的格式化器\r\n            const argsContent =  formatter.substr(firstIndex+1,lastIndex-firstIndex-1).trim()\r\n            let args = argsContent==\"\" ? [] :  argsContent.split(\",\").map(arg=>{\r\n                arg = arg.trim()\r\n                if(!isNaN(parseInt(arg))){\r\n                    return parseInt(arg)                  // 数字\r\n                }else if((arg.startsWith('\\\"') && arg.endsWith('\\\"')) || (arg.startsWith('\\'') && arg.endsWith('\\'')) ){\r\n                    return arg.substr(1,arg.length-2)       // 字符串\r\n                }else if(arg.toLowerCase()===\"true\" || arg.toLowerCase()===\"false\"){\r\n                    return arg.toLowerCase()===\"true\"     // 布尔值\r\n                }else if((arg.startsWith('{') && arg.endsWith('}')) || (arg.startsWith('[') && arg.endsWith(']'))){      \r\n                    try{\r\n                        return JSON.parse(arg)\r\n                    }catch(e){\r\n                        return String(arg)\r\n                    }\r\n                }else{\r\n                    return String(arg)\r\n                }\r\n            })\r\n            return [formatter.substr(0,firstIndex),args]\r\n        }else{// 不带参数的格式化器\r\n            return [formatter,[]]\r\n        }        \r\n    }) \r\n}\r\n\r\n/**  \r\n * 提取字符串中的插值变量\r\n *     // [\r\n    //   {  \r\n        name:<变量名称>,formatters:[{name:<格式化器名称>,args:[<参数>,<参数>,....]]｝],<匹配字符串>],\r\n    //   ....\r\n    // \r\n * @param {*} str \r\n * @param {*} isFull   =true 保留所有插值变量 =false 进行去重\r\n * @returns {Array} \r\n * [\r\n *  {\r\n *      name:\"<变量名称>\",\r\n *      formatters:[\r\n *          {name:\"<格式化器名称>\",args:[<参数>,<参数>,....]},\r\n *          {name:\"<格式化器名称>\",args:[<参数>,<参数>,....]},\r\n *      ],\r\n *      match:\"<匹配字符串>\"\r\n *  },\r\n *  ...\r\n * ]\r\n */\r\nfunction getInterpolatedVars(str){\r\n    let vars = []\r\n    forEachInterpolatedVars(str,(varName,formatters,match)=>{\r\n        let varItem = {\r\n            name:varName,\r\n            formatters:formatters.map(([formatter,args])=>{\r\n                return {\r\n                    name:formatter,\r\n                    args:args\r\n                }\r\n            }),\r\n            match:match\r\n        }\r\n        if(vars.findIndex(varDef=>((varDef.name===varItem.name) && (varItem.formatters.toString() == varDef.formatters.toString())))===-1){\r\n            vars.push(varItem) \r\n        }\r\n        return \"\"\r\n    }) \r\n    return vars\r\n}\r\n/**\r\n * 遍历str中的所有插值变量传递给callback，将callback返回的结果替换到str中对应的位置\r\n * @param {*} str \r\n * @param {Function(<变量名称>,[formatters],match[0])} callback \r\n * @returns  返回替换后的字符串\r\n */\r\nfunction forEachInterpolatedVars(str,callback,options={}){\r\n    let result=str, match \r\n    let opts = Object.assign({\r\n        replaceAll:true,                // 是否替换所有插值变量，当使用命名插值时应置为true，当使用位置插值时应置为false\r\n    },options)\r\n    varWithPipeRegexp.lastIndex=0\r\n    while ((match = varWithPipeRegexp.exec(result)) !== null) {\r\n        const varname = match.groups.varname || \"\"\r\n        // 解析格式化器和参数 = [<formatterName>,[<formatterName>,[<arg>,<arg>,...]]]\r\n        const formatters = parseFormatters(match.groups.formatters)\r\n        if(typeof(callback)===\"function\"){\r\n            try{\r\n                if(opts.replaceAll){\r\n                    result=result.replaceAll(match[0],callback(varname,formatters,match[0]))\r\n                }else{\r\n                    result=result.replace(match[0],callback(varname,formatters,match[0]))\r\n                }                \r\n            }catch{// callback函数可能会抛出异常，如果抛出异常，则中断匹配过程\r\n                break   \r\n            }            \r\n        }\r\n        varWithPipeRegexp.lastIndex=0\r\n    }\r\n    return result\r\n}\r\n/**\r\n * 将要翻译内容提供了一个非文本内容时进行默认的转换\r\n *  - 对函数则执行并取返回结果()\r\n *  - 对Array和Object使用JSON.stringify\r\n *  - 其他类型使用toString\r\n * \r\n * @param {*} value \r\n * @returns \r\n */\r\nfunction transformToString(value){\r\n    let result  = value\r\n    if(typeof(result)===\"function\") result = value()\r\n    if(!(typeof(result)===\"string\")){\r\n        if(Array.isArray(result) || isPlainObject(result)){\r\n            result = JSON.stringify(result)\r\n        }else{\r\n            result = result.toString()\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\nfunction resetScopeCache(scope,activeLanguage=null){\r\n    scope.$cache = {activeLanguage,typedFormatters:{},formatters:{}}\r\n}\r\n/**\r\n *   取得指定数据类型的默认格式化器 \r\n *   \r\n *   可以为每一个数据类型指定一个默认的格式化器,当传入插值变量时，\r\n *   会自动调用该格式化器来对值进行格式化转换\r\n \r\n    const formatters =  {   \r\n        \"*\":{\r\n            $types:{...}                                    // 在所有语言下只作用于特定数据类型的格式化器\r\n        },                                      // 在所有语言下生效的格式化器    \r\n        zh:{            \r\n            $types:{         \r\n                [数据类型]:(value)=>{...},\r\n            }, \r\n            [格式化器名称]:(value)=>{...},\r\n            [格式化器名称]:(value)=>{...},\r\n            [格式化器名称]:(value)=>{...},\r\n        },\r\n    }\r\n * @param {*} scope \r\n * @param {*} activeLanguage \r\n * @param {*} dataType    数字类型\r\n * @returns {Function} 格式化函数  \r\n */\r\nfunction getDataTypeDefaultFormatter(scope,activeLanguage,dataType){\r\n    if(!scope.$cache) resetScopeCache(scope)\r\n    if(scope.$cache.activeLanguage === activeLanguage) {\r\n        if(dataType in scope.$cache.typedFormatters) return scope.$cache.typedFormatters[dataType]\r\n    }else{// 当语言切换时清空缓存\r\n        resetScopeCache(scope,activeLanguage)\r\n    }\r\n\r\n    // 先在当前作用域中查找，再在全局查找\r\n    const targets = [scope.formatters,scope.global.formatters]  \r\n    for(const target of targets){\r\n        if(!target) continue\r\n        // 优先在当前语言的$types中查找\r\n        if((activeLanguage in target) && isPlainObject(target[activeLanguage].$types)){ \r\n            let formatters = target[activeLanguage].$types  \r\n            if(dataType in formatters && typeof(formatters[dataType])===\"function\"){                \r\n                return scope.$cache.typedFormatters[dataType] = formatters[dataType]\r\n            }  \r\n        }\r\n        // 在所有语言的$types中查找\r\n        if((\"*\" in target) && isPlainObject(target[\"*\"].$types)){\r\n            let formatters = target[\"*\"].$types \r\n            if(dataType in formatters && typeof(formatters[dataType])===\"function\"){                \r\n                return scope.$cache.typedFormatters[dataType] = formatters[dataType]\r\n            }  \r\n        }   \r\n    }     \r\n}\r\n\r\n/**\r\n * 获取指定名称的格式化器函数\r\n * @param {*} scope \r\n * @param {*} activeLanguage \r\n * @param {*} name  格式化器名称\r\n * @returns  {Function} 格式化函数  \r\n */ \r\nfunction getFormatter(scope,activeLanguage,name){\r\n    // 缓存格式化器引用，避免重复检索\r\n    if(!scope.$cache) resetScopeCache(scope)\r\n    if(scope.$cache.activeLanguage === activeLanguage) {\r\n        if(name in scope.$cache.formatters) return scope.$cache.formatters[name]\r\n    }else{// 当语言切换时清空缓存\r\n        resetScopeCache(scope,activeLanguage)\r\n    }\r\n    // 先在当前作用域中查找，再在全局查找\r\n    const targets = [scope.formatters,scope.global.formatters]  \r\n    for(const target of targets){\r\n        // 优先在当前语言查找\r\n        if(activeLanguage in target){  \r\n            let formatters = target[activeLanguage] || {}   \r\n            if((name in formatters) && typeof(formatters[name])===\"function\") return scope.$cache.formatters[name] = formatters[name]\r\n        }\r\n        // 在所有语言的$types中查找\r\n        let formatters = target[\"*\"] || {}   \r\n        if((name in formatters) && typeof(formatters[name])===\"function\") return scope.$cache.formatters[name] = formatters[name]\r\n    }     \r\n}\r\n\r\n/**\r\n * 执行格式化器并返回结果\r\n * @param {*} value \r\n * @param {*} formatters  多个格式化器顺序执行，前一个输出作为下一个格式化器的输入\r\n */\r\nfunction executeFormatter(value,formatters){\r\n    if(formatters.length===0) return value\r\n    let result = value\r\n    try{\r\n        for(let formatter of formatters){\r\n            if(typeof(formatter) === \"function\") {\r\n                result = formatter(result)\r\n            }else{// 如果碰到无效的格式化器，则跳过过续的格式化器\r\n                return result \r\n            }\r\n        }\r\n    }catch(e){\r\n        console.error(`Error while execute i18n formatter for ${value}: ${e.message} ` )\r\n    }    \r\n    return result\r\n}\r\n/**\r\n * 将  [[格式化器名称,[参数,参数,...]]，[格式化器名称,[参数,参数,...]]]格式化器转化为\r\n *   \r\n * \r\n * \r\n * @param {*} scope \r\n * @param {*} activeLanguage \r\n * @param {*} formatters \r\n */\r\nfunction buildFormatters(scope,activeLanguage,formatters){\r\n    let results = [] \r\n    for(let formatter of formatters){\r\n        if(formatter[0]){\r\n            const func = getFormatter(scope,activeLanguage,formatter[0])\r\n            if(typeof(func)===\"function\"){\r\n                results.push((v)=>{\r\n                    return func(v,...formatter[1])\r\n                })\r\n            }else{\r\n                // 格式化器无效或者没有定义时，查看当前值是否具有同名的原型方法，如果有则执行调用\r\n                // 比如padStart格式化器是String的原型方法，不需要配置就可以直接作为格式化器调用\r\n                results.push((v)=>{\r\n                    if(typeof(v[formatter[0]])===\"function\"){\r\n                        return v[formatter[0]].call(v,...formatter[1])\r\n                    }else{\r\n                        return v\r\n                    }        \r\n                })  \r\n            }              \r\n        }\r\n    }\r\n    return results\r\n} \r\n\r\n/**\r\n *  将value经过格式化器处理后返回\r\n * @param {*} scope \r\n * @param {*} activeLanguage \r\n * @param {*} formatters \r\n * @param {*} value \r\n * @returns \r\n */\r\nfunction getFormattedValue(scope,activeLanguage,formatters,value){\r\n    // 1. 取得格式化器函数列表\r\n    const formatterFuncs = buildFormatters(scope,activeLanguage,formatters) \r\n    // 2. 查找每种数据类型默认格式化器,并添加到formatters最前面，默认数据类型格式化器优先级最高\r\n    const defaultFormatter =  getDataTypeDefaultFormatter(scope,activeLanguage,getDataTypeName(value)) \r\n    if(defaultFormatter){\r\n        formatterFuncs.splice(0,0,defaultFormatter)\r\n    }             \r\n    // 3. 执行格式化器\r\n    value = executeFormatter(value,formatterFuncs)     \r\n    return value\r\n}\r\n\r\n/**\r\n * 字符串可以进行变量插值替换，\r\n *    replaceInterpolatedVars(\"<模板字符串>\",{变量名称:变量值,变量名称:变量值,...})\r\n *    replaceInterpolatedVars(\"<模板字符串>\",[变量值,变量值,...])\r\n *    replaceInterpolatedVars(\"<模板字符串>\",变量值,变量值,...])\r\n * \r\n- 当只有两个参数并且第2个参数是{}时，将第2个参数视为命名变量的字典\r\n    replaceInterpolatedVars(\"this is {a}+{b},{a:1,b:2}) --> this is 1+2\r\n- 当只有两个参数并且第2个参数是[]时，将第2个参数视为位置参数\r\n    replaceInterpolatedVars\"this is {}+{}\",[1,2]) --> this is 1+2\r\n- 普通位置参数替换\r\n    replaceInterpolatedVars(\"this is {a}+{b}\",1,2) --> this is 1+2\r\n- \r\nthis == scope == { formatters: {}, ... }\r\n* @param {*} template \r\n* @returns \r\n*/\r\nfunction replaceInterpolatedVars(template,...args) {\r\n    const scope = this\r\n    // 当前激活语言\r\n    const activeLanguage = scope.global.activeLanguage \r\n    let result=template\r\n\r\n    // 没有变量插值则的返回原字符串  \r\n    if(args.length===0 || !hasInterpolation(template)) return template \r\n\r\n    // ****************************变量插值****************************\r\n    if(args.length===1 && isPlainObject(args[0])){  \r\n        // 读取模板字符串中的插值变量列表\r\n        // [[var1,[formatter,formatter,...],match],[var2,[formatter,formatter,...],match],...}\r\n        let varValues = args[0]\r\n        return forEachInterpolatedVars(template,(varname,formatters)=>{\r\n            let value =  (varname in varValues) ? varValues[varname] : ''\r\n            return getFormattedValue(scope,activeLanguage,formatters,value)  \r\n        })   \r\n    }else{  \r\n        // ****************************位置插值****************************\r\n        // 如果只有一个Array参数，则认为是位置变量列表，进行展开\r\n        const params=(args.length===1 && Array.isArray(args[0])) ?  [...args[0]] : args     \r\n        if(params.length===0) return template    // 没有变量则不需要进行插值处理，返回原字符串  \r\n        let i = 0\r\n        return forEachInterpolatedVars(template,(varname,formatters)=>{\r\n            if(params.length>i){ \r\n                return getFormattedValue(scope,activeLanguage,formatters,params[i++]) \r\n            }else{\r\n                throw new Error()   // 抛出异常，停止插值处理\r\n            }\r\n        },{replaceAll:false})\r\n         \r\n    }\r\n    return result\r\n}    \r\n\r\n// 默认语言配置\r\nconst defaultLanguageSettings = {  \r\n    defaultLanguage: \"zh\",\r\n    activeLanguage: \"zh\",\r\n    languages:[\r\n        {name:\"zh\",title:\"中文\",default:true},\r\n        {name:\"en\",title:\"英文\"}\r\n    ],\r\n    formatters:inlineFormatters \r\n}\r\n\r\nfunction isMessageId(content){\r\n    return parseInt(content)>0\r\n}\r\n/**\r\n * 根据值的单数和复数形式，从messages中取得相应的消息\r\n * \r\n * @param {*} messages  复数形式的文本内容 = [<=0时的内容>，<=1时的内容>，<=2时的内容>,...]\r\n * @param {*} value \r\n */\r\nfunction getPluraMessage(messages,value){\r\n    try{\r\n        if(Array.isArray(messages)){\r\n            return messages.length > value ? messages[value] : messages[messages.length-1]\r\n       }else{\r\n           return messages\r\n       }\r\n    }catch{\r\n        return Array.isArray(messages) ? messages[0] : messages\r\n    }\r\n}\r\nfunction escape(str){\r\n    return str.replaceAll(/\\\\(?![trnbvf'\"]{1})/g,\"\\\\\\\\\")\r\n        .replaceAll(\"\\t\",\"\\\\t\")\r\n        .replaceAll(\"\\n\",\"\\\\n\")\r\n        .replaceAll(\"\\b\",\"\\\\b\")\r\n        .replaceAll(\"\\r\",\"\\\\r\")\r\n        .replaceAll(\"\\f\",\"\\\\f\")\r\n        .replaceAll(\"\\'\",\"\\\\'\")\r\n        .replaceAll('\\\"','\\\\\"')\r\n        .replaceAll('\\v','\\\\v')       \r\n}\r\nfunction unescape(str){\r\n    return str\r\n        .replaceAll(\"\\\\t\",\"\\t\")\r\n        .replaceAll(\"\\\\n\",\"\\n\")\r\n        .replaceAll(\"\\\\b\",\"\\b\")\r\n        .replaceAll(\"\\\\r\",\"\\r\")\r\n        .replaceAll(\"\\\\f\",\"\\f\")\r\n        .replaceAll(\"\\\\'\",\"\\'\")\r\n        .replaceAll('\\\\\"','\\\"')\r\n        .replaceAll('\\\\v','\\v')       \r\n        .replaceAll(/\\\\\\\\(?![trnbvf'\"]{1})/g,\"\\\\\")\r\n}\r\n/**\r\n * 翻译函数\r\n * \r\n* translate(\"要翻译的文本内容\")                                 如果默认语言是中文，则不会进行翻译直接返回\r\n* translate(\"I am {} {}\",\"man\") == I am man                    位置插值\r\n* translate(\"I am {p}\",{p:\"man\"})                              字典插值\r\n* translate(\"total {$count} items\", {$count:1})  //复数形式 \r\n* translate(\"total {} {} {} items\",a,b,c)  // 位置变量插值\r\n * \r\n * this===scope  当前绑定的scope\r\n * \r\n */\r\nfunction translate(message) { \r\n    const scope = this\r\n    const activeLanguage = scope.global.activeLanguage \r\n    let content = message\r\n    let vars=[]                 // 插值变量列表\r\n    let pluralVars= []          // 复数变量\r\n    let pluraValue = null       // 复数值\r\n    if(!typeof(message)===\"string\") return message\r\n    try{\r\n        // 1. 预处理变量:  复数变量保存至pluralVars中 , 变量如果是Function则调用 \r\n        if(arguments.length === 2 && isPlainObject(arguments[1])){\r\n            Object.entries(arguments[1]).forEach(([name,value])=>{\r\n                if(typeof(value)===\"function\"){\r\n                    try{\r\n                        vars[name] = value()\r\n                    }catch(e){\r\n                        vars[name] = value\r\n                    }\r\n                } \r\n                // 以$开头的视为复数变量\r\n                if(name.startsWith(\"$\") && typeof(vars[name])===\"number\")  pluralVars.push(name)\r\n            })\r\n            vars = [arguments[1]]\r\n        }else if(arguments.length >= 2){\r\n            vars = [...arguments].splice(1).map((arg,index)=>{\r\n                try{\r\n                    arg = typeof(arg)===\"function\" ? arg() : arg                    \r\n                    // 位置参数中以第一个数值变量为复数变量\r\n                    if(isNumber(arg)) pluraValue = parseInt(arg)    \r\n                }catch(e){ }\r\n                return arg   \r\n            })\r\n            \r\n        }\r\n        \r\n        \r\n       \r\n\r\n        // 3. 取得翻译文本模板字符串\r\n        if(activeLanguage === scope.defaultLanguage){\r\n            // 2.1 从默认语言中取得翻译文本模板字符串\r\n            // 如果当前语言就是默认语言，不需要查询加载，只需要做插值变换即可\r\n            // 当源文件运用了babel插件后会将原始文本内容转换为msgId\r\n            // 如果是msgId则从scope.default中读取,scope.default=默认语言包={<id>:<message>}\r\n            if(isMessageId(content)){\r\n                content = scope.default[content] || message\r\n            }\r\n        }else{ \r\n            // 2.2 从当前语言包中取得翻译文本模板字符串\r\n            // 如果没有启用babel插件将源文本转换为msgId，需要先将文本内容转换为msgId\r\n            // JSON.stringify在进行转换时会将\\t\\n\\r转换为\\\\t\\\\n\\\\r,这样在进行匹配时就出错 \r\n            let msgId = isMessageId(content) ? content :  scope.idMap[escape(content)]  \r\n            content = scope.messages[msgId] || content\r\n            content = Array.isArray(content) ? content.map(v=>unescape(v)) : unescape(content)\r\n        }\r\n         // 2. 处理复数\r\n        // 经过上面的处理，content可能是字符串或者数组\r\n        // content = \"原始文本内容\" || 复数形式[\"原始文本内容\",\"原始文本内容\"....]\r\n        // 如果是数组说明要启用复数机制，需要根据插值变量中的某个变量来判断复数形式\r\n        if(Array.isArray(content) && content.length>0){\r\n            // 如果存在复数命名变量，只取第一个复数变量\r\n            if(pluraValue!==null){  // 启用的是位置插值,pluraIndex=第一个数字变量的位置\r\n                content = getPluraMessage(content,pluraValue)\r\n            }else if(pluralVar.length>0){\r\n                content = getPluraMessage(content,parseInt(vars(pluralVar[0])))\r\n            }else{ // 如果找不到复数变量，则使用第一个内容\r\n                content = content[0]\r\n            }\r\n        } \r\n        \r\n        // 进行插值处理\r\n        if(vars.length==0){\r\n            return content\r\n        }else{\r\n            return replaceInterpolatedVars.call(scope,content,...vars)\r\n        }        \r\n    }catch(e){\r\n        return content       // 出错则返回原始文本\r\n    } \r\n}\r\n \r\n/** \r\n * 多语言管理类\r\n * \r\n * 当导入编译后的多语言文件时(import(\"./languages\"))，会自动生成全局实例VoerkaI18n\r\n *  \r\n * VoerkaI18n.languages             // 返回支持的语言列表\r\n * VoerkaI18n.defaultLanguage       // 默认语言\r\n * VoerkaI18n.language              // 当前语言\r\n * VoerkaI18n.change(language)      // 切换到新的语言 \r\n * \r\n * \r\n * VoerkaI18n.on(\"change\",(language)=>{})  // 注册语言切换事件\r\n * VoerkaI18n.off(\"change\",(language)=>{}) \r\n * \r\n * */ \r\n class I18nManager extends EventEmitter{\r\n    constructor(settings={}){\r\n        super()\r\n        if(I18nManager.instance!=null){\r\n            return I18nManager.instance;\r\n        }\r\n        I18nManager.instance = this;\r\n        this._settings = deepMerge(defaultLanguageSettings,settings)\r\n        this._scopes=[]  \r\n        return I18nManager.instance;\r\n    }\r\n    get settings(){ return this._settings }\r\n    get scopes(){ return this._scopes }\r\n    // 当前激活语言\r\n    get activeLanguage(){ return this._settings.activeLanguage}\r\n    // 默认语言\r\n    get defaultLanguage(){ return this._settings.defaultLanguage}\r\n    // 支持的语言列表\r\n    get languages(){ return this._settings.languages}\r\n    // 内置格式化器\r\n    get formatters(){ return inlineFormatters }\r\n    /**\r\n     *  切换语言\r\n     */\r\n    async change(value){\r\n        value=value.trim()\r\n        if(this.languages.findIndex(lang=>lang.name === value)!==-1){\r\n            // 通知所有作用域刷新到对应的语言包\r\n            await this._refreshScopes(value)\r\n            this._settings.activeLanguage = value\r\n            /// 触发语言切换事件\r\n            await this.emit(value)            \r\n        }else{\r\n            throw new Error(\"Not supported language:\"+value)\r\n        }\r\n    }\r\n    /**\r\n     * 当切换语言时调用此方法来加载更新语言包\r\n     * @param {*} newLanguage \r\n     */\r\n    async _refreshScopes(newLanguage){ \r\n        // 并发执行所有作用域语言包的加载\r\n        try{\r\n            const scopeRefreshers = this._scopes.map(scope=>{\r\n                return scope.refresh(newLanguage)\r\n            })\r\n            if(Promise.allSettled){\r\n                await Promise.allSettled(scopeRefreshers)\r\n            }else{\r\n                await Promise.all(scopeRefreshers)\r\n            } \r\n        }catch(e){\r\n            console.warn(\"Error while refreshing i18n scopes:\",e.message)\r\n        }         \r\n    }\r\n    /**\r\n     * \r\n     * 注册一个新的作用域\r\n     * \r\n     * 每一个库均对应一个作用域，每个作用域可以有多个语言包，且对应一个翻译函数\r\n     * 除了默认语言外，其他语言采用动态加载的方式\r\n     * \r\n     * @param {*} scope \r\n     */\r\n    async register(scope){\r\n        if(!(scope instanceof i18nScope)){\r\n            throw new TypeError(\"Scope must be an instance of I18nScope\")\r\n        }\r\n        this._scopes.push(scope) \r\n        await scope.refresh(this.activeLanguage) \r\n    }\r\n    /**\r\n     * 注册全局格式化器\r\n     * 格式化器是一个简单的同步函数value=>{...}，用来对输入进行格式化后返回结果\r\n     * \r\n     * registerFormatters(name,value=>{...})                                 // 适用于所有语言\r\n     * registerFormatters(name,value=>{...},{langauge:\"zh\"})                 // 适用于cn语言\r\n     * registerFormatters(name,value=>{...},{langauge:\"en\"})                 // 适用于en语言 \r\n     \r\n     * @param {*} formatters \r\n     */\r\n    registerFormatter(name,formatter,{language=\"*\"}={}){\r\n        if(!typeof(formatter)===\"function\" || typeof(name)!==\"string\"){\r\n            throw new TypeError(\"Formatter must be a function\")\r\n        }        \r\n        if(DataTypes.includes(name)){\r\n            this.formatters[language].$types[name] = formatter\r\n        }else{\r\n            this.formatters[language][name] = formatter\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports ={\r\n    getInterpolatedVars,\r\n    replaceInterpolatedVars,\r\n    I18nManager,\r\n    translate,\r\n    i18nScope,\r\n    defaultLanguageSettings,\r\n    getDataTypeName,\r\n    isNumber,\r\n    isPlainObject \r\n}","/**\r\n *    内置的格式化器\r\n * \r\n */\r\n\r\n\r\n/**\r\n *   字典格式化器\r\n *   根据输入data的值，返回后续参数匹配的结果\r\n *   dict(data,<value1>,<result1>,<value2>,<result1>,<value3>,<result1>,...)\r\n *   \r\n * \r\n *   dict(1,1,\"one\",2,\"two\",3,\"three\"，4,\"four\") == \"one\"\r\n *   dict(2,1,\"one\",2,\"two\",3,\"three\"，4,\"four\") == \"two\"\r\n *   dict(3,1,\"one\",2,\"two\",3,\"three\"，4,\"four\") == \"three\"\r\n *   dict(4,1,\"one\",2,\"two\",3,\"three\"，4,\"four\") == \"four\"\r\n *   // 无匹配时返回原始值\r\n *   dict(5,1,\"one\",2,\"two\",3,\"three\"，4,\"four\") == 5  \r\n *   // 无匹配时并且后续参数个数是奇数，则返回最后一个参数\r\n *   dict(5,1,\"one\",2,\"two\",3,\"three\"，4,\"four\",\"more\") == \"more\"  \r\n * \r\n *   在翻译中使用\r\n *   I have { value | dict(1,\"one\",2,\"two\",3,\"three\",4,\"four\")} apples\r\n * \r\n * @param {*} value \r\n * @param  {...any} args \r\n * @returns \r\n */\r\n function dict(value,...args){\r\n    for(let i=0;i<args.length;i+=2){\r\n        if(args[i]===value){\r\n            return args[i+1]\r\n        }\r\n    }\r\n    if(args.length >0 && (args.length % 2!==0)) return args[args.length-1]\r\n    return value\r\n}\r\n\r\nfunction formatCurrency(value,symbol,retainDots){\r\n\r\n}\r\n\r\nmodule.exports = {     \r\n    \"*\":{\r\n        $types:{\r\n            Date:(value)=>value.toLocaleString()\r\n        },\r\n        time:(value)=>  value.toLocaleTimeString(),  \r\n        shorttime:(value)=>  value.toLocaleTimeString(),  \r\n        date: (value)=> value.toLocaleDateString(),     \r\n        dict,   //字典格式化器\r\n    },   \r\n    zh:{ \r\n        $types:{\r\n            Date:(value)=> `${value.getFullYear()}年${value.getMonth()+1}月${value.getDate()}日 ${value.getHours()}点${value.getMinutes()}分${value.getSeconds()}秒`\r\n        },\r\n        shortime:(value)=>  value.toLocaleTimeString(),  \r\n        time:(value)=>`${value.getHours()}点${value.getMinutes()}分${value.getSeconds()}秒`,     \r\n        date: (value)=> `${value.getFullYear()}年${value.getMonth()+1}月${value.getDate()}日`,\r\n        shortdate: (value)=> `${value.getFullYear()}-${value.getMonth()+1}-${value.getDate()}`,\r\n        currency:(value)=>`${value}元`,\r\n    },\r\n    en:{\r\n        currency:(value)=>{\r\n            return `$${value}`\r\n        }\r\n    }\r\n}"],"names":["utils","obj","_typeof","proto","_Object$getPrototypeOf","baseProto","value","isNaN","_parseInt","deepMerge","toObj","formObj","options","results","_Object$assign","key","_Array$isArray","array","v","undefined","constructor","name","eventemitter","_callbacks","callback","_includesInstanceProperty","push","i","this","length","args","_Promise","allSettled","_mapInstanceProperty","cb","all","DataTypes","scope","_id","id","Date","getTime","toString","Math","random","_languages","languages","_defaultLanguage","defaultLanguage","_activeLanguage","activeLanguage","_default","_messages","messages","_idMap","idMap","_formatters","formatters","_loaders","loaders","_global","$cache","typedFormatters","_globalThis","VoerkaI18n","I18nManager","require$$0","global","_loading","register","then","formatter","language","TypeError","$types","newLanguage","resolve","loader","console","warn","_context3","message","_fallback","_bindInstanceProperty","on","off","offAll","change","getDataTypeName","isNumber","isPlainObject","EventEmitter","require$$1","i18nScope","require$$2","inlineFormatters","toLocaleString","time","toLocaleTimeString","shorttime","date","toLocaleDateString","dict","zh","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","shortime","shortdate","currency","en","varWithPipeRegexp","hasInterpolation","str","parseFormatters","result","substr","split","r","_trimInstanceProperty","firstIndex","_indexOfInstanceProperty","lastIndex","_lastIndexOfInstanceProperty","argsContent","arg","_startsWithInstanceProperty","_endsWithInstanceProperty","toLowerCase","String","JSON","parse","e","forEachInterpolatedVars","match","opts","replaceAll","exec","varname","groups","_replaceAllInstanceProperty","replace","resetScopeCache","buildFormatters","func","target","getFormatter","call","getFormattedValue","formatterFuncs","defaultFormatter","dataType","getDataTypeDefaultFormatter","error","executeFormatter","replaceInterpolatedVars","template","varValues","params","Error","defaultLanguageSettings","title","isMessageId","content","getPluraMessage","escape","unescape","settings","instance","_settings","_scopes","_findIndexInstanceProperty","lang","_refreshScopes","emit","scopeRefreshers","refresh","_context31","runtime","getInterpolatedVars","vars","varName","varItem","varDef","translate","pluralVars","pluraValue","arguments","index","msgId","pluralVar"],"mappings":"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"}